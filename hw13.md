# 1. 阅读Pseudocode Standard.
## 1) 用伪代码描述将十进制转化为十六进制的方法  
READ num  

IF num < 0 THEN  

	PRINT "-"  
  
	num = -num  
  
ENDIF  

Transition(num)  

END READ  


FUNCTION Transition(num)  

	num1 = num % 16  
  
	IF num / 16 != 0 THEN  
  
	Transition(num / 16)  
  
	END IF  
  
	CASE num1 OF   
  
		0 : PRINT "0"  
    
		1 : PRINT "1"  
    
		2 : PRINT "2"  
    
		3 : PRINT "3"  
    
		4 : PRINT "4"  
    
		5 : PRINT "5"  
    
		6 : PRINT "6"  
    
		7 : PRINT "7"  
    
		8 : PRINT "8"  
    
		9 : PRINT "9"  
    
		10 : PRINT "A"  
    
		11 : PRINT "B"  
    
		12 : PRINT "C"  
    
		13 : PRINT "D"  
    
		14 : PRINT "E"  
    
		15 : PRINT "F"  
    
	END CASE  
  
END FUNCTION Transition	  
## 2）用C语言实现
#include<stdio.h>  

void Transition(int num);  

int main()//主函数读取十进制数，并调用转换函数打印出该数的十六进制形式  

{	  

	int num;  
  
	scanf("%d", &num);  
  
	if(num < 0) num = -num;  
  
	Transition(num);  
  
	return 0;  
  
}  


void Transition(int num)  

{	  

	int num1 = num % 16; //得到该层要打印的十六进制的其中一位数  
  
	if( num / 16 != 0)  
  
	{  
  
		Transition(num / 16); //通过递归实现从左到右打印十六进制数  
    
	}  
  
	switch(num1) // 分情况输出  
  
	{  
  
		case 0 : printf("0"); break;  
    
		case 1 : printf("1"); break;  
    
		case 2 : printf("2"); break;  
    
		case 3 : printf("3"); break;  
    
		case 4 : printf("4"); break;  
    
		case 5 : printf("5"); break;  
    
		case 6 : printf("6"); break;  
    
		case 7 : printf("7"); break;  
    
		case 8 : printf("8"); break;  
    
		case 9 : printf("9"); break;  
    
		case 10 : printf("A"); break;  
    
		case 11 : printf("B"); break;  
    
		case 12 : printf("C"); break;  
    
		case 13 : printf("D"); break;  
    
		case 14 : printf("E"); break;  
    
		case 15 : printf("F"); break;  
    
	}  
  
}  
## 3)使用-1,0,1,15,26,3265最为输入测试你的程序
-1, 0, 1, F, 1A, E29
# 名词解释与对比
## 1）Top-down design
本质上是系统的破坏，以逆向工程的方式深入了解其组成子系统。 在自上而下的方法中，系统概述，指定但不详细说明任何第一级子系统。 然后，每个子系统都会更详细地进行细化，有时在许多其他子系统级别中进行细化，直到整个规范缩减为基本元素。 自上而下的模型通常在“黑匣子”的帮助下指定，这使得操作更容易。 但是，黑匣子可能无法澄清基本机制或足够详细以实际验证模型。 自上而下的方法始于全局。 它从那里分解成更小的部分。
## 2)Work breakdown structure（WBS）
WBS是项目的分层和增量分解，分为阶段，可交付成果和工作包。 它是一种树状结构 ，显示了实现目标所需的细分; 例如程序 ， 项目和合同 。 在项目或合同中，WBS的开发是从最终目标开始，并在规模，持续时间和责任方面（例如，系统，子系统，组件， 任务 ，子任务和工作）将其细分为可管理的组件。包括实现目标所需的所有步骤。
## 3)简述管理学WBS与信息学Top-down设计的异同
  同：都是分解一个系统，以深入了解其中的子系统。
  异：WBS是对完成项目必须完成的所有任务的分层描述。 最低层级的任务定义了可以明确定义的工作单元，并且可以准确地计算其时间，成本和资源需求。它包括了自上而下和自下而上两种划分方法；Top-down只是一种自上而下的一种分法。
# 仔细观察你洗衣机的运作过程，运用Top-down设计方法和Pseudocode描述洗衣机控制程序。假设洗衣机可执行的基本操作如下： 
water_in_switch(open_close) // open 打开上水开关，close关闭 
water_out_switch(open_close) // open 打开排水开关，close关闭 
get_water_volume() //返回洗衣机内部水的高度
motor_run(direction) // 电机转动。left左转，right右转，stop停
time_counter() // 返回当前时间计数，以秒为单位 
halt(returncode) //停机，success 成功 failure 失败 
## 1）请使用伪代码分解“正常洗衣”程序的大步骤，包括注水、浸泡等 
先注水，再浸泡，再转动，再排水  
water_in_switch(open)  
get_water_volume()  
water_in_switch(close)  
motor_run(left)  
motor_run(stop)  
motor_run(right)  
motor_run(stop)  
motor_run(left)  
motor_run(stop)  
motor_run(right)  
motor_run(stop)  
water_out_switch(open)  
get_water_volume()  
water_out_switch(colse)  
## 2）进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式，写出每个步骤的伪代码
READ (Volumewater Washtime)  
if water_volume < Volumewater  
  then water_in_switch(open) 
       get_water_volume()  
if enough  
  then record time  
       water_in_switch(colse)  
       motor_run(left)   
       motor_run(right)   
if time >= Washtime  
  then motor_run(stop)  
       water_out_switch(open)  
if empty  
  then water_out_switch(colse)  
  
       
## 3）根据你的实践，请分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同。 你认为是否存在改进（创新）空间，简单说明你的改进意见？ 
若要考虑“快速洗衣”和“正常洗衣”的模式，就得考虑在现实生活中是否会有用户会存在时间上的问题，因此，我认为应当将快速洗衣模式加入其中（起码我就存在这样的问题。。）
## 4）通过步骤3），提取一些共性功能模块（函数），简化“正常洗衣”程序，使程序变得更利于人类理解和修改维护。
### 例如： wait(time) //等待指定的时间； 注水(volume,timeout) //在指定时间内完成注水，否则停机； 排水(timeout)。 等子程序
READ (Mode Volumewater Washtime)//mod1是快速洗衣模式，mod2是正常洗衣模式
if water_volume < Volumewater  
   then water_in_switch(open)  
     get_water_volume()  
if enough  
   then water_in_switch(colse)  
   record time//time1是快速洗衣模式的时间，time2是正常洗衣模式的时间  
   if Mode = mod1 then Washtime = time1  
   if Mode = mod2 then Washtime = time2
   then motor_run(left)  
        motor_run(right)  
if time >= Washtime  
   then motor _run(stop)  
        water_out_switch(open)  
if empty  
   then water_out_switch(close)  
